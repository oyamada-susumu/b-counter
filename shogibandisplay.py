# 将棋盤表示システム 2023-
# コンピュータの配列のイメージで駒を配置したほうが考えやすいか？
# 読み上げ「8六歩」⇔ コンピュータの配列[5]行[1]列に歩
# 筋⇒  ９     ８     ７     ６     ５     ４     ３     ２     １
# 一段 [0][0] [0][1] [0][2] [0][3] [0][4] [0][5] [0][6] [0][7] [0][8]
# 二段 [1][0] [1][1] [1][2] [1][3] [1][4] [1][5] [1][6] [1][7] [1][8]
# 三段 [2][0] [2][1] [2][2] [2][3] [2][4] [2][5] [2][6] [2][7] [2][8]
# 四段 [3][0] [3][1] [3][2] [3][3] [3][4] [3][5] [3][6] [3][7] [3][8]
# 五段 [4][0] [4][1] [4][2] [4][3] [4][4] [4][5] [4][6] [4][7] [4][8]
# 六段 [5][0] [5][1] [5][2] [5][3] [5][4] [5][5] [5][6] [5][7] [5][8]
# 七段 [6][0] [6][1] [6][2] [6][3] [6][4] [6][5] [6][6] [6][7] [7][8]
# 八段 [7][0] [7][1] [7][2] [7][3] [7][4] [7][5] [7][6] [7][7] [7][8]
# 九段 [8][0] [8][1] [8][2] [8][3] [8][4] [8][5] [8][6] [8][7] [8][8]
# 計算式 配列[i][j]とすると, i=段-1,j=9-筋, 逆に,筋=9-j, 段=i+1
# 駒の移動方向と距離
# 玉(0,-1),(0,1),(1,-1),(1,0),(1,1),(-1,0),(-1.-1),(-1,1)
#    左 　　右　  下左　 下　  下右　 上　　上左　　上右
# 飛(0,-8),(0,-7),(0,-6),(0,-5),(0,-4),(0,-3),(0,-2),(0,-1),
#   (0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8)
#   (0,-1),(0,-2),(0,-3),(0,-4),(0,-5),
# 角(k, k) -8<=k<=8
# 桂(i, j) -1<=i<=1, 先手 j=-2, 後手 j=2
# 香(0, j) -8<=j<=8, 先手 -8<=j<=0 後手 0<=j<=8
# 盤の外 (x,y), (x<0 or x>8) or (y<0 or y>8)
# ↑↓ドモルガンの法則になっている
# 盤の内 (x,y), (-1<x and x<9) and (-1<y and y<9)
# 駒の番号　0   1    2    3    4    5    6    7    8    9   10   11     12     13     14
# koma = ["  ","王","飛","角","金","銀","桂","香","歩","竜","馬","成銀","成桂","成香","と"]
# 先手・後手　駒の区別
# 案1 +20   0　21   22   23   24   25   26   27   28   29   30   31 　  32 　　33 　  34
# 案2 *(-1)  0　-1   -2   -3   -4   -5    -6   -7   -8   -9   -10  -11    -12   -13  -34
# 　表示するときは、マイナスをかけてインテックスとして、リストからコマ名を得る
# 　取った駒にはマイナスをかける、ただし、成駒は戻してから、
# 　2飛 成 9竜
# 　3角 成 10馬
#   5銀 成 11成銀
# 　6桂 成 12成桂
# 　7香 成 13成香
# 　8歩 成 14と
# なれない駒（王は1金は2）とすると成駒のオフセット値は+6で統一できる：不採用
# 盤上にある駒か、持ち駒かを区別する 持ち駒リストを作るか？
# 読み上げは「先手７六歩」のように筋７、行六の順番
#（案）グラフにプロットするときはどマイナスをかけて
# 　先手(７,六,歩)は第３象限の点P(-7,-6)に歩があると考えると表示イメージと一致する
# 　駒の動ける方向は（x軸方向，y軸方向）で指定できる。
# 　相手駒がとれる、駒がきいているかは、直線の方程式が格子点を通るかどうかで判定できる
# 　先手 歩(0,-1)  歩(七,5)とすると移動できるのは直線 x = -7（-7 < x <= -6)上の格子点(-7,-6)だけ
# 　後手 歩(0,1)
# 　先手 香(0,-1),(0,-2),(0,-3),(0,-4),(0,-5),(0,-6),(0,-7),(0,-8)
# 　後手 香(0,1),(0,2)(0,3),(0,4),(0,5),(0,6),(0,7),(0,8)
# 　先手 桂：(1,-2), (1,-2)
# 　後手 桂：(-1,2), (1,2)
# 　先手 金：前(0,1), 右前(1,1), 右(1,0), 下(0,-1), 左(-1,0), 左前(-1,1)
# 　　　　　　↑金の方向ベクトルと考える
# 　直線上の点かどうかの判定は駒の座標(x,y)を直線の方程式に代入してイコールが成り立つかどうかで判定する
###############################
# -9 -8 -7 -6 -5 -4 -3 -2 -1　0
#                            -1
#                            -2
#　　　　　　　　　　　　　　-3
#　　　　　　　　　　　　　　-4
#　　　　　　　　　　　　　　-5
#　　　 歩　　　　 　　　　　-6
#　　　　　　　　　　　　　　-7
#　　　　　　　　　　　　　　-8
#　　　　　　　　　　　　　　-9
###############################
####################################################################################
# 駒ごとに移動ベクトル　扱いにくいか？
#          　↑←　　↑　　  ↑→　　   ←　    →　 ↓←　   ↓　　 ↓→
# idogyoku     = [[-1,-1],[-1, 0],[-1, 1],[ 0,-1],[ 0, 1],[ 1,-1],[ 1, 0],[ 1, 1]]
# idokinsente  = [[-1,-1],[-1, 0],[-1, 1],[ 0,-1],[ 0, 1],        [ 1, 0]        ]
# idokingote   = [        [-1, 0],        [ 0,-1],[ 0, 1],[ 1,-1],[ 1, 0],[ 1, 1]]
# idogin       = [[-1,-1],[-1, 0],[-1, 1],                [ 1,-1],[ 1, 0],[ 1, 1]]
# idokeisente  = [[-2,-1],[-2, 1]]
# idokeigote   = [[ 2,-1],[ 2, 1]]
# idokyousente = [[-1, 0],[-2, 0],[-3, 0],[-4, 0],[-5, 0],[-6, 0],[-7, 0],[-8, 0]]
# idokyougote  = [[ 1, 0],[ 2, 0],[ 3, 0],[ 4, 0],[ 5, 0],[ 6, 0],[ 7, 0],[ 8, 0]]
# idofusente   = [[-1, 0]]
# idofugote    = [[ 1, 0]]
# idohisha = [[-1, 0],[-2, 0],[-3, 0],[-4, 0],[-5, 0],[-6, 0],[-7, 0],[-8, 0],
#            [ 1, 0],[ 2, 0],[ 3, 0],[ 4, 0],[ 5, 0],[ 6, 0],[ 7, 0],[ 8, 0],
#            [ 0,-1],[ 0,-2],[ 0,-3],[ 0,-4],[ 0,-5],[ 0,-6],[ 0,-7],[ 0,-8],
#            [ 0, 1],[ 0, 2],[ 0, 3],[ 0, 4],[ 0, 5],[ 0, 6],[ 0, 7],[ 0, 8]]
# idokaku  = [[-1,-1],[-2,-2],[-3,-3],[-4,-4],[-5,-5],[-6,-6],[-7,-7],[-8,-8],
#            [-1, 1],[-2, 2],[-3, 3],[-4, 4],[-5, 5],[-6, 6],[-7, 7],[-8, 8],
#            [ 1,-1],[ 2,-2],[ 3,-3],[ 4,-4],[ 5,-5],[ 6,-6],[ 7,-7],[ 8,-8],
#            [ 1, 1],[ 2, 2],[ 3, 3],[ 4, 4],[ 5, 5],[ 6, 6],[ 7, 7],[ 8, 8]]
####################################################################################
# 詰将棋１手詰め　次の一手
# 現在の後手玉の位置を検索する。
# 王手がかかっていないかを
# 現在の全ての駒の玉に対する効きを調べる
# 　現在の全ての駒を一つずつ移動させ駒の効きを調べる
# 開き王手を調べる
#     駒を移動させたことにより、他の駒から王手がかかることがある。
#     駒を移動させたときに、開き王手になっているか調べる。
# 　　王手をかけている駒を一つ取り出す
#     玉の逃げ道を探索する
#     玉に逃げ道があれば不正解
# 王手になっているか
#     玉の八方向に駒がいるか調べる。
#     その駒の方向ベクトルが玉に向いているか、一手で玉に届くか調べる。
# 合駒ができるか調べる
#     合駒をとる
#     無駄な合駒か判定する。
#
################################################################################
##  PROGRAM  START
################################################################################
#  SCOPE IS GLOBAL.
######################
# import math
# 王（おう）玉（ぎょく）2種類の駒がある場合は上位の者が王を使う。将棋解説では上下が分かりにくいので両方とも玉が使われる。
komaSente = ["  　  ","  玉  ","  飛  ","  角  ","  金  ","  銀  ","  桂  ","  香  ","  歩  ","  竜  ","  馬  "," 成銀 "," 成桂 "," 成香 ","  と  "]
komaGote  = ["      "," V玉  "," V飛  "," V角  "," V金  "," V銀  "," V桂  "," V香  "," V歩  "," V竜  "," V馬  ","V成銀 ","V成桂 ","V成香 "," Vと  "]
komaSente2= [" 　　"," 玉　"," 飛　"," 角　"," 金　"," 銀　"," 桂　"," 香　"," 歩　"," 竜　"," 馬　","V成銀"," 成桂"," 成香"," と　"]
komaGote2 = [" 　　","V玉　","V飛　","V角　","V金　","V銀　","V桂　","V香　","V歩　","V竜　","V馬　","V成銀","V成桂","V成香","Vと　"]
# 読み上げ用テキスト　配列の添え字で拾えば、通常の盤面表示の筋段になる
sengo = ["先手","後手"]
sente = 0; gote = 1
suji  = ["９","８","７","６","５","４","３","２","１"]
dan   = ["一","二","三","四","五","六","七","八","九"]
retsu = ["０","１","２","３","４","５","６","７","８"]
gyou  = ["０","１","２","３","４","５","６","７","８"]
#           0    1    2    3    4    5    6    7    8    9    10   11     12     13     14
komamei = ["　","玉","飛","角","金","銀","桂","香","歩","竜","馬","成銀","成桂","成香","と"]
sentegyoku=1; sentehisya=2; sentekaku=3; sentekin=4; sentegin=5; sentekei=6; sentekyou=7; sentefu=8
gotegyoku=-1; gotehisya=-2; gotekaku=-3; gotekin=-4; gotegin=5; gotekei=-6; gotekyou=-7; gotefu=-8
senteryuu=10; senteuma=10; sentenarigin=11; sentenarikei=12; sentenarikyou=13; sentetokin=14
goteryuu=-11; goteuma=-10; gotenarigin=-11; gotenarikei=-12; gotenarikyou=-13; gotetokin=-14
# 取った成駒は元に戻り持ち駒となる。
# nari[駒番号]:成ることができる駒は成駒の添え字,成駒は0とする。更に成ることはできない。一度成ると元の駒に戻れない。
# 先手は３段目に入って成、不成が選べる。３段目以上内の移動でも成ることができる。３段目以上内より以下への移動でも成ることができる。
# 後手は７段目に入って成、不成が選べる。７段目以下内の移動でもなることができる。７段目以下内より以上への移動でも成ることができる。
nari   = [0,0,9,10,0,11,12,13,14,0,0,0,0,0,0]
modori = [0,1,2,3,4,5,6,7,8,2,3,5,6,7,8]
# 移動方向用ベクトル：盤面上方向から時計回り。駒が進める方向[0-7]の8方向と桂先手[8][9]桂後手[10][11]の4方向の合計12方向。
idovec = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1],[-2,-1],[-2,1],[2,-1],[2,1]]
# 駒の移動方向[i][j] iは駒番号、jは駒の進める方向。盤面上方向から時計回り。ただし,9,10,11,12は桂専用。
# i= 0駒なし、1玉、2飛、3角、4金、5銀、6桂、7香、8歩、9竜、10馬、11成銀、12成桂、12成香、13と
# j= 0移動なし、1上、2右上、3右、4右下、5下、6左下、7左、8左上、9桂馬先手左上、10桂先手右上、11桂後手左下、12桂後手右下
# 値は駒が進める最大数。
# 玉1、飛8、角8、金1、銀1、桂1(先手用は[6][8]=1,[6][9]=1,後手用は[6][10]=1,[6][11]=1)
# 香8、歩1、竜8と1、馬8と1、成銀1、成桂1、成香1、と1
idosente = [
    [0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,0,0,0,0],
    [8,0,8,0,8,0,8,0,0,0,0,0],
    [0,8,0,8,0,8,0,8,0,0,0,0],
    [1,1,1,0,1,0,1,1,0,0,0,0],
    [1,1,0,1,1,1,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,0,0],
    [8,0,0,0,0,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0,0,0,0,0],
    [8,1,8,1,8,1,8,1,0,0,0,0],
    [1,8,1,8,1,8,1,8,0,0,0,0],
    [1,1,1,0,1,0,1,1,0,0,0,0],
    [1,1,1,0,1,0,1,1,0,0,0,0],
    [1,1,1,0,1,0,1,1,0,0,0,0],
    [1,1,1,0,1,0,1,1,0,0,0,0],
    ]
idogote = [
    [0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,0,0,0,0],
    [8,0,8,0,8,0,8,0,0,0,0,0],
    [0,8,0,8,0,8,0,8,0,0,0,0],
    [1,0,1,1,1,1,0,1,0,0,0,0],
    [1,1,0,1,1,1,0,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,1,1],
    [0,0,0,0,8,0,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,0,0,0],
    [8,1,8,1,8,1,8,1,0,0,0,0],
    [1,8,1,8,1,8,1,8,0,0,0,0],
    [1,0,1,1,1,1,0,1,0,0,0,0],
    [1,0,1,1,1,1,0,1,0,0,0,0],
    [1,0,1,1,1,1,0,1,0,0,0,0],
    [1,0,1,1,1,1,0,1,0,0,0,0],
    ]
################################
ban0 =  [
    [-7,-6,-5,-4,-1,-4,-5,-6,-7],
    [ 0,-2, 0, 0, 0, 0, 0,-3, 0],
    [-8,-8,-8,-8,-8,-8,-8,-8,-8],
    [ 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [ 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [ 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [ 8, 8, 8, 8, 8, 8, 8, 8, 8],
    [ 0, 3, 0, 0, 0, 0, 0, 2, 0],
    [ 7, 6, 5, 4, 1, 4, 5, 6, 7]
    ]
#################################
ban =  [
    [-7,-6, 7,-4, 8,-4,-5,-6,-7],
    [ 0,-2, 0, 6, 0, 0, 0,-3, 0],
    [-8,-8,-8,-8,-8,-8,-8,-8,-8],
    [ 0, 0, 0, 0, 0, 3, 0, 0, 0],
    [ 0, 0, -1, 0, 0, 0, 0, 0, 0],
    [ 0, 0, 0, 0, 8, 0, 0, 0, 0],
    [ 0, 8, 0, 6, 0, 8, 8, 8, 8],
    [ 0, 0, 0, 0, 0, 0, 0, 2, 0],
    [ 7, 0, 5, 4, 1, 4, 5, 6, 7]
    ]
kikisente = [
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
    ]
kikigote = [
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0]
    ]
################################################################################
##  FUNCTION START. SCOPE IS LOCAL IN FUNCTION WITHOUT UPPER↑GLOBAL VALIABLE.
################################################################################
def sujihyoujiue():
#   print("　", end="")
#   print("    ０      １      ２      ３      ４      ５      ６      ７      ８")
    msg = "　" + "    ０      １      ２      ３      ４      ５      ６      ７      ８"
    print(msg)

####
def sujihyoujishita():
    print("　", end="")
    print("    ９      ８      ７      ６      ５      ４      ３      ２      １")
####
def keisenhajime():
    print("　", end="")
    print("┌───", end="")
    for i in range(8):
        print("┬───",end="")
    print("┐")
####
def keisennaka():
    print("　",end="")
    print("├───",end="")
    for i in range(8):
        print("┼───",end="")
    print("┤")
    return()
####
def keisenowari():
    print("　",end="")
    print("└───",end="")
    for i in range(8):
        print("┴───",end="")
    print("┘")
####
def danhyouji(i):
#### i:行[0-8], j:列[0-8]
    print(gyou[i], end="")
    print("│",end="")
    msg =""
    for j in range(9):
        if ban[i][j] < 0:
            msg = komaGote[abs(ban[i][j])]
        else:
            msg = komaSente[ban[i][j]]
        msg = msg + "│"
        print(msg, end="")
    print(dan[i])
####
def danhyoujiKuu():
    print("　│",end="")
    for j in range(9):
        dan = komaSente[0]
        dan = dan + "│"
        print(dan, end="")
    print("")
################################################################################
def banhyouji():
    for i in range(9):
        if i == 0:
            sujihyoujiue()
            keisenhajime()
            danhyoujiKuu()
            danhyouji(i)
            keisennaka()
        elif i == 8:
            danhyoujiKuu()
            danhyouji(i)
            keisenowari()
            sujihyoujishita()
        else:
            danhyoujiKuu()
            danhyouji(i)
            keisennaka()
###############################################################################
def banhyouji2():
    print("*** 先手の駒の効き banyouji2 ***")
    print("")
    for i in range(9):
        for j in range(9):
            if ban[i][j] < 0:
                msg = komaGote2[abs(ban[i][j])]
            else:
                msg = komaSente2[ban[i][j]]
            msg = str(kikisente[i][j]) + msg
            print(msg, end="")
        #print("")
        print("")
    print("")
################################################################################
def banhyouji3():
    print("*** 後手の駒の効き banyouji3 ***")
    print("")
    for i in range(9):
        for j in range(9):
            if ban[i][j] < 0:
                msg = komaGote2[abs(ban[i][j])]
            else:
                msg = komaSente2[ban[i][j]]
            msg = str(kikigote[i][j]) + msg
            print(msg, end="")
        #print("")
        print("")
    print("")
################################################################################
def yomiage(s,i,j,k):
    # s=0:先手, s=1:後手, i:行, j:列, k:駒の種類
    txt = sengo[s]+suji[j]+dan[i]+komamei[k]
    return(txt)
################################################################################
def findkoma(komano):
    # 使い方例 komanoは駒番号 先手s=0 後手s=1
    # arg = findKoma(1)  先手の玉を探索する
    # arg = findKoma(-1) 後手の玉を探索する
    # 戻り値 arg[0]=玉の位置i, arg[1]=玉の位置j
    arg = []
    for i in range(9):
        for j in range(9):
            if ban[i][j] == komano:
                arg.append([i,j])
    return(arg)
################################################################################
## 先手専用
################################################################################
def findoute(i,j,koma,gyokui,gyokuj):
# 戻り値　oute=0 王手でない oute=1 王手である
    oute=0
    #msg = komamei[koma]+str(i)+str(j)+" "; print(msg,end="")
# 全方向を探索する
    for direction in range(12):
        if idosente[koma][direction] > 0:
            #print("方向", str(direction), end=" ")
# 距離を１から最大まで探索する
            for distance in range(1, idosente[koma][direction]+1, 1):
                veci = i + idovec[direction][0] * distance
                vecj = j + idovec[direction][1] * distance
                if (-1 < veci) and (veci < 9) and (-1 < vecj) and (vecj < 9):
                    if ban[veci][vecj] != 0:
                        kikisente[veci][vecj] = kikisente[veci][vecj] + 1
                        #王手か判断する
                        if (veci == gyokui) and (vecj == gyokuj):
                            oute = 1
                        #print("距離", distance,"×", end=" ")
                        # 利きの行き止まり(for文break)次の方向を探索する。
                        break
                    else:
                        kikisente[veci][vecj] = kikisente[veci][vecj] + 1
                        #print("距離", distance,"〇", end=" ")
                        # 次の距離で利きを調べる。
    #print("")
    return(oute)
################################################################################
## 後手専用
################################################################################
## 引数 koma は, koma = abs(ban[i][j]) としてからこの関数を呼ぶこと
def findoute2(i,j,koma,gyokui,gyokuj):
    oute = 0
    #msg = komamei[koma]+str(i)+str(j)+" "; print(msg,end="")
# 全方向を探索する
    for direction in range(12):
        if idogote[koma][direction] > 0:
            #print("方向", str(direction), end=" ")
# 距離を１から最大まで探索する
            for distance in range(1, idogote[koma][direction]+1, 1):
                veci = i + idovec[direction][0] * distance
                vecj = j + idovec[direction][1] * distance
                if (-1 < veci) and (veci < 9) and (-1 < vecj) and (vecj < 9):
                    if ban[veci][vecj] != 0:
                        kikigote[veci][vecj] = kikigote[veci][vecj] + 1
                        #print("距離", distance,"×", end=" ")
                        # 利きの行き止まり(for文break)次の方向を探索する。
                        break
                    else:
                        kikigote[veci][vecj] = kikigote[veci][vecj] + 1
                        #print("距離", distance,"〇", end=" ")
                        # 次の距離で利きを調べる。
    #print("")
    return(oute)
################################################################################
def findnifu(s):
# s先手0,後手1
    nifu = []
    if s == 0:
        fu = sentefu
    else:
        fu = gotefu
    for j in range(9):
        fucount = 0
        for i in range(9):
            if (ban[i][j]) == fu:
                fucount = fucount + 1
        nifu.append(fucount)
    return(nifu)
################################################################################
def findikidomari(s):
# s先手0,後手1
    ikidomari = []
    if s == sente:
        dan1 = 0; dan2 = 1; fu = sentefu; kyou = sentekyou; kei = sentekei
    else:
        dan1 = 8; dan2 = 7; fu = gotefu; kyou = gotekyou; kei = gotekei
    for j in range(9):
        if ban[dan1][j] == fu:
            ikidomari.append([s,dan1,j,fu])
        if ban[dan1][j] == kyou:
            ikidomari.append([s,dan1,j,kyou])
        if ban[dan1][j] == kei:
            ikidomari.append([s,dan1,j,kei])
        if ban[dan2][j] == kei:
            ikidomari.append([s,dan2,j,kei])
    return(ikidomari)
################################################################################
##  FUNCTION  END
################################################################################
arg = findkoma(gotegyoku)
gi = arg[0][0]
gj = arg[0][1]
for i in range(9):
    for j in range(9):
        if ban[i][j] > 0:
            outeflag = findoute(i,j,ban[i][j],gi,gj)
            if outeflag == 1:
                print("先手 ☗",komamei[ban[i][j]],i,j,"が, ☖ 後手","玉",gi,gj,"に王手をかけています。")
if kikisente[gi][gj] > 0:
   print("後手 ☖","玉",gi,gj,"に",kikisente[gi][gj],"方向から王手がかかっています。")
   print("")
banhyouji2()
##
for i in range(9):
    for j in range(9):
        if ban[i][j] < 0:
            findoute2(i,j,abs(ban[i][j]),gi,gj)
banhyouji3()
print("先手☗ 二歩", findnifu(sente))
print("後手☖ 二歩", findnifu(gote))
print("先手☗ 行き止まり", findikidomari(sente))
print("後手☖ 行き止まり", findikidomari(gote))
banhyouji()

"""
######################################################
## 先手駒の全てを1手ずつ動かして、王手を調べる。
## 歩9*1 香2*8 桂2*2 銀2*6 金2*6 角2*4*8 飛2*4*8 玉1*8
######################################################
# SAVE 駒の位置[i][j] 駒の種類(k) 探索の方向(direction) 探索の距離(distance)
######################################################
for i in range(9):
    for j in range(9):
        if ban[i][j] > 0:
            komasente = ban[i][j]
# DIRECTION
            for direction in range(12):
                if idosente[komasente][direction] > 0:
# DISTANCE
                    for distance in range(1, idosente[komasente][direction]+1, 1):
                        veci = i + idovec[direction][0] * distance
                        vecj = j + idovec[direction][1] * distance
                        if (-1 < veci) and (veci < 9) and (-1 < vecj) and (vecj < 9):
                            if ban[veci][vecj] > 0:
                                print(ban[veci][vecj],veci,vecj,"方向",direction,"距離",distance,"先手の駒　行き止まり",end=" ")
                                # 行き止まり(for文break)次の方向を探索する。
                                break
                            if ban[veci][vecj] < 0:
                                print(ban[veci][vecj],veci,vecj,"方向",direction,"距離",distance,"後手の駒　取る",end=" ")
                                komagote = ban[veci][vecj]
                                ban[veci][vecj] = komasente
                                ban[i][j] = 0
                                # 王手を調べる 王手なら（とりあえず）おわり、王手でなければもどす。
                                ban[veci][vecj] = komagote
                                ban[j][j] = komasente
                                break
                            else:
                                ban[veci][vecj] = komasente
                                ban[i][j] = 0
                                # 王手を調べる 王手なら（とりあえず）おわり、王手でなければもどす。
                                ban[veci][vecj] = 0
                                ban[j][j] = komasente
                                break
"""
